"[[.utilizationDistribution" <- function(x, i)
{
	if (!inherits(x, "utilizationDistribution"))
		stop("x should be of class \"utilizationDistribution\"")
	
	ud <- NextMethod("[[") # use the default list selection operator to extract the requested element

	# If a UD was previously filtered, restore it again before extracting from the result set
	cutoff <- attr(ud, "cutoff")
	if (!is.null(cutoff)) {
		res <- matrix(0, nrow=cutoff$dim[1], ncol=cutoff$dim[2])
		res[cutoff$rows[1]:cutoff$rows[2], cutoff$cols[1]:cutoff$cols[2]] <- ud

		attrs <- attributes(ud)
		attrs$dim <- dim(res)

		if (!is.null(cutoff$dimnames)) {
			attrs$dimnames <- cutoff$dimnames
		}
		attrs$cutoff <- NULL
		attributes(res) <- attrs
		
		ud <- res
	}
	
	ud
}

"utilizationDistribution" <- function(tr, grid=NULL, timestepSize=60, xc=NULL, yc=NULL,
		grid.dim=100, grid.pad=0.2, byburst=FALSE, cutoff.level=1) {
	tr <- na.omit(tr) # Filter out missing measurements, these break the algorithm
		
	if (inherits(grid,"asc")) {
		# extract the grid lines from the provided grid
		xc <- seq(from=attr(grid, "xll"), by=attr(grid, "cellsize"), length.out=attr(grid, "dim")[1])
		yc <- seq(from=attr(grid, "yll"), by=attr(grid, "cellsize"), length.out=attr(grid, "dim")[2])
	} else if (!is.null(grid)) {
		stop("grid must be an instance of 'asc' if set")
	}
	
	if (is.null(xc) || is.null(yc)) {
		g <- .defaultGrid(tr, grid.dim, grid.pad)
		xc <- g$x
		yc <- g$y
	}
	
	timeSteps <- .UDtimesteps(tr, timestepSize, byburst)
	
	UDs <- list()
	# For each timestep, compute the mean location, variance, and a weighing factor
	for (id in names(timeSteps)) {
		ts <- timeSteps[[id]]

		gxc <- xc
		gyc <- yc
		if (cutoff.level < 1) {
			# Find a box that is guaranteed to contain the requested contour.
			# The bounding box containing the cutoff.level contour for every time step
			# is guaranteed to contain this contour for the whole trajectory.
			vDiff <- sqrt(ts[,'var'] * -2 * log(1-cutoff.level))
			gRows <- which(xc >= min(ts[,'x'] - vDiff) & xc <= max(ts[,'x'] + vDiff))
			gxc <- xc[gRows]
			gCols <- which(yc >= min(ts[,'y'] - vDiff) & yc <= max(ts[,'y'] + vDiff))
			gyc <- yc[gCols]
		}
		
		pad <- rep(0, 15)
			
		cResult <- .OpenCL("utilizationDistribution", length(gxc)*length(gyc),
				as.integer(nrow(ts)),
				as.double(c(ts[,1],pad)), as.double(c(ts[,2],pad)), as.double(c(ts[,3],pad+1)), as.double(c(ts[,4],pad)), 
				as.double(gxc), as.double(gyc), as.integer(length(gyc)), as.integer(length(gxc)))

		res <- matrix(cResult, nrow=length(gxc), byrow=TRUE)
		
		if (!is.null(grid)) {
			attrs <- attributes(grid)
			attrs$dim <- attr(res, 'dim')
			attributes(res) <- attrs
		} else {
			rownames(res) <- gxc
			colnames(res) <- gyc
		}
		
		if (cutoff.level < 1) {
			# Remember the original dimensions of the requested grid and where the cut-out box fits in
			attr(res, 'cutoff') <- list(
					rows=range(gRows), 
					cols=range(gCols), 
					dim=c(length(xc),length(yc)), 
					dimnames=(if (is.null(grid)) list(xc, yc) else NULL)
			)
		}
		
		UDs[[id]] <- res
	}
	
	class(UDs) <- c("utilizationDistribution", "list")
	if (byburst) {
		attr(UDs, "id") <- as.factor(sapply(timeSteps, function(t) {attr(t, "id") }))
	}
	return(UDs)
}

"utilizationDistribution.byID" <- function(ud) {
	if (!inherits(ud,"utilizationDistribution") || is.null(attr(ud, "id"))) {
		stop("ud must be generated by utilizationDistribution with byburst=TRUE")
	}
	groups <- split(ud, attr(ud, "id"))
	
	UDs <- lapply(groups, function(g) {
		class(g) <- class(ud)
		Reduce('+', g)
	})
	class(UDs) <- class(ud)
	UDs
}

"encounterDistribution" <- function(tr, threshold, grid=NULL, timestepSize=60, xc=NULL, yc=NULL,
		grid.dim=100, grid.pad=0.2) {
	tr <- bbFilterNA(tr) # Filter out missing measurements, these break the algorithm
	
	if (inherits(grid,"asc")) {
		# extract the grid lines from the provided grid
		xc <- seq(from=attr(grid, "xll"), by=attr(grid, "cellsize"), length.out=attr(grid, "dim")[1])
		yc <- seq(from=attr(grid, "yll"), by=attr(grid, "cellsize"), length.out=attr(grid, "dim")[2])
	} else if (!is.null(grid)) {
		stop("grid must be an instance of 'asc' if set")
	}
	
	if (is.null(xc) || is.null(yc)) {
		g <- .defaultGrid(tr, grid.dim, grid.pad)
		xc <- g$x
		yc <- g$y
	}	
	
	useFields <- c("x","y","diff.coeff","loc.var","t")
	
	timeSteps <- .UDtimesteps(tr, timestepSize)
	ids <- names(timeSteps)
	
	# UDs is two-dimensional list where each entry represents the distribution of encounters for a pair of groups
	UDs <- as.list(rep(NA, length(ids)^2))
	dim(UDs) <- c(length(ids), length(ids))
	rownames(UDs) <- colnames(UDs) <- ids
	
	for (id1 in ids) {
		# It makes no sense to compute encounters between a group and itself, so don't do that
		for (id2 in ids[-which(ids==id1)]) {
			# encounters can only be determined if we have a position estimate for both IDs
			encounterTimes <- intersect(rownames(timeSteps[[id1]]), rownames(timeSteps[[id2]]))
			
			weight <- pmin(timeSteps[[id1]][encounterTimes,'weight'], timeSteps[[id2]][encounterTimes,'weight'])
			
			ts  <- timeSteps[[id1]][encounterTimes,]
			ts2 <- timeSteps[[id2]][encounterTimes,]
			
			pad <- rep(0, 15)
			
			cResult <- .OpenCL("encounterUD", length(xc)*length(yc),
			as.double(threshold), as.integer(length(encounterTimes)),
			as.double(c( ts[,1],pad)), as.double(c( ts[,2], pad)), as.double(c( ts[,3],pad+1)), as.double(c(ts[,4], pad)),
			as.double(c(ts2[,1],pad)), as.double(c(ts2[,2], pad)), as.double(c(sqrt(ts2[,3]),pad+1)),
			as.double(xc), as.double(yc), as.integer(length(yc)), as.integer(length(xc)))
			
			res <- matrix(cResult, nrow=length(xc), byrow=TRUE)			
		
			if (!is.null(grid)) {
				attributes(res) <- attributes(grid)
			} else {
				rownames(res) <- xc
				colnames(res) <- yc
			}
			
			UDs[[id1,id2]] <- res
		}
	}
	diag(UDs) <- utilizationDistribution(tr, timestepSize=timestepSize, xc=xc, yc=yc)
	#class(UDs) <- c("utilizationDistribution", "list")
	return(UDs)
}

".UDtimesteps" <- function(tr, timestepSize=60, byburst=FALSE) {
	if (byburst) {
		names <- unique(adehabitatLT::burst(tr))
	} else {
		names <- unique(adehabitatLT::id(tr))
	}
	result <- list()
	
	tr <- na.omit(tr)
	
	for (name in names) {
		if (byburst) {
			bursts <- tr[sapply(tr, nrow) >= 2][burst=name]
		} else {
			bursts <- tr[sapply(tr, nrow) >= 2][id=name]
		}
		result[[name]] <- do.call("rbind", lapply(bursts, function(burst) {
				burst$t <- as.double(burst$date)
				burst <- burst[,c("x","y","diff.coeff","loc.var","t")]
				data <- c(t(burst)) # flatten into vector in row-major order
				
				# Align the time of each step to a multiple of timestepSize
				timeLimits <- timestepSize*round(burst$t[c(1,nrow(burst))]/timestepSize)
				nsteps <- as.integer((timeLimits[2] - timeLimits[1]) / timestepSize) + 1
				
				cResult <- .C("UDTimesteps", double(nsteps*4),
						as.integer(nrow(burst)), as.double(data),
						as.integer(nsteps), as.double(timeLimits))
				timeSteps <- matrix(cResult[[1]], ncol=4, byrow=T)
				colnames(timeSteps) <- c('x', 'y', 'var', 'weight')
				rownames(timeSteps) <- seq(timeLimits[1], timeLimits[2], length=nrow(timeSteps))
				return(timeSteps)
		}))
		if (byburst) {
			attr(result[[name]], "id") <- attr(bursts[[1]], "id")
		}
	}
	return(result)
}

".defaultGrid" <- function(tr, grid.dim, padding) {
	padding <- rep(padding, length.out=4)

	xr <- range(unlist(sapply(tr, function(b) { b$x })))
	xpad <- padding[c(2,4)] * (xr[2]-xr[1])
	xr <- c(xr[1]-xpad[2], xr[2]+xpad[1])
	
	yr <- range(unlist(sapply(tr, function(b) { b$y })))
	ypad <- padding[c(1,3)] * (yr[2]-yr[1])
	yr <- c(yr[1]-ypad[2], yr[2]+ypad[1])

	cellSize <- min(xr[2] - xr[1], yr[2]-yr[1]) / grid.dim
	
	return(list(
		x=seq(xr[1], xr[2], by=cellSize),
		y=seq(yr[1], yr[2], by=cellSize)
	))
}
