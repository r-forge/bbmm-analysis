"[[.utilizationDistribution" <- function(x, i)
{
	if (!inherits(x, "utilizationDistribution"))
		stop("x should be of class \"utilizationDistribution\"")
	
	ud <- NextMethod("[[") # use the selection operator from ltraj to select the right bursts

	# If a UD was previously filtered, restore it again before extracting from the result set
	cutoff <- attr(ud, "cutoff")
	if (!is.null(cutoff)) {
		res <- matrix(0, nrow=cutoff$dim[1], ncol=cutoff$dim[2])
		res[cutoff$rows[1]:cutoff$rows[2], cutoff$cols[1]:cutoff$cols[2]] <- ud

		attrs <- attributes(ud)
		attrs$dim <- dim(res)

		if (!is.null(cutoff$dimnames)) {
			attrs$dimnames <- cutoff$dimnames
		}
		attrs$cutoff <- NULL
		attributes(res) <- attrs
		
		ud <- res
	}
	
	ud
}

"utilizationDistribution" <- function(tr, grid=NULL, timestepSize=60, xc=NULL, yc=NULL,
		grid.dim=100, grid.pad=0.2, byburst=FALSE, cutoff.level=1) {
	tr <- na.omit(tr) # Filter out missing measurements, these break the algorithm
		
	if (inherits(grid,"asc")) {
		# extract the grid lines from the provided grid
		xc <- seq(from=attr(grid, "xll"), by=attr(grid, "cellsize"), length.out=attr(grid, "dim")[1])
		yc <- seq(from=attr(grid, "yll"), by=attr(grid, "cellsize"), length.out=attr(grid, "dim")[2])
	} else if (!is.null(grid)) {
		stop("grid must be an instance of 'asc' if set")
	}
	
	if (is.null(xc) || is.null(yc)) {
		g <- .defaultGrid(tr, grid.dim, grid.pad)
		xc <- g$x
		yc <- g$y
	}
	
	timeSteps <- .UDtimesteps(tr, timestepSize, byburst)
	
	UDs <- list()
	# For each timestep, compute the mean location, variance, and a weighing factor
	for (id in names(timeSteps)) {
		ts <- timeSteps[[id]]
	
		pad <- rep(0, 15)
			
		cResult <- .OpenCL("utilizationDistribution", length(xc)*length(yc),
				as.integer(nrow(ts)),
				as.double(c(ts[,1],pad)), as.double(c(ts[,2],pad)), as.double(c(ts[,3],pad+1)), as.double(c(ts[,4],pad)), 
				as.double(xc), as.double(yc), as.integer(length(yc)), as.integer(length(xc)))

		res <- matrix(cResult, nrow=length(xc), byrow=TRUE)
		
		if (!is.null(grid)) {
			attributes(res) <- attributes(grid)
		} else {
			rownames(res) <- xc
			colnames(res) <- yc
		}
		
		# Keep only the most interesting parts of the result to save memory
		if (cutoff.level < 1) {
			levels <- .UD.alphaLevels(res)
			# Find the smallest bounding box that contains all interesting values
			rows <- range(which(apply(levels, 1, function(r) { any(r <= cutoff.level) })))
			cols <- range(which(apply(levels, 2, function(c) { any(c <= cutoff.level) })))
			
			attrs <- attributes(res)
			res <- res[rows[1]:rows[2],cols[1]:cols[2]]
			# Remember the original dimensions of the result and where the cut-out box fits in
			attrs$cutoff <- list(rows=rows, cols=cols, dim=attrs$dim, dimnames=attrs$dimnames)
			attrs$dim <- dim(res)
			attrs$dimnames <- NULL

			attributes(res) <- attrs
		}
		
		UDs[[id]] <- res
	}
	
	class(UDs) <- c("utilizationDistribution", "list")
	if (byburst) {
		attr(UDs, "id") <- as.factor(sapply(timeSteps, function(t) {attr(t, "id") }))
	}
	return(UDs)
}

"utilizationDistribution.byID" <- function(ud) {
	if (!inherits(ud,"utilizationDistribution") || is.null(attr(ud, "id"))) {
		stop("ud must be generated by utilizationDistribution with byburst=TRUE")
	}
	groups <- split(ud, attr(ud, "id"))
	
	UDs <- lapply(groups, function(g) { 
		class(g) <- class(ud)
		Reduce('+', g)
	})
	class(UDs) <- class(ud)
	UDs
}

"encounterDistribution" <- function(tr, threshold, grid=NULL, timestepSize=60, xc=NULL, yc=NULL,
		grid.dim=100, grid.pad=0.2) {
	tr <- bbFilterNA(tr) # Filter out missing measurements, these break the algorithm
	
	if (inherits(grid,"asc")) {
		# extract the grid lines from the provided grid
		xc <- seq(from=attr(grid, "xll"), by=attr(grid, "cellsize"), length.out=attr(grid, "dim")[1])
		yc <- seq(from=attr(grid, "yll"), by=attr(grid, "cellsize"), length.out=attr(grid, "dim")[2])
	} else if (!is.null(grid)) {
		stop("grid must be an instance of 'asc' if set")
	}
	
	if (is.null(xc) || is.null(yc)) {
		g <- .defaultGrid(tr, grid.dim, grid.pad)
		xc <- g$x
		yc <- g$y
	}	
	
	useFields <- c("x","y","diff.coeff","loc.var","t")
	
	timeSteps <- .UDtimesteps(tr, timestepSize)
	ids <- names(timeSteps)
	
	# UDs is two-dimensional list where each entry represents the distribution of encounters for a pair of groups
	UDs <- as.list(rep(NA, length(ids)^2))
	dim(UDs) <- c(length(ids), length(ids))
	rownames(UDs) <- colnames(UDs) <- ids
	
	for (id1 in ids) {
		# It makes no sense to compute encounters between a group and itself, so don't do that
		for (id2 in ids[-which(ids==id1)]) {
			# encounters can only be determined if we have a position estimate for both IDs
			encounterTimes <- intersect(rownames(timeSteps[[id1]]), rownames(timeSteps[[id2]]))
			
			weight <- pmin(timeSteps[[id1]][encounterTimes,'weight'], timeSteps[[id2]][encounterTimes,'weight'])
			
			ts  <- timeSteps[[id1]][encounterTimes,]
			ts2 <- timeSteps[[id2]][encounterTimes,]
			
			pad <- rep(0, 15)
			
			cResult <- .OpenCL("encounterUD", length(xc)*length(yc),
			as.double(threshold), as.integer(length(encounterTimes)),
			as.double(c( ts[,1],pad)), as.double(c( ts[,2], pad)), as.double(c( ts[,3],pad+1)), as.double(c(ts[,4], pad)),
			as.double(c(ts2[,1],pad)), as.double(c(ts2[,2], pad)), as.double(c(sqrt(ts2[,3]),pad+1)),
			as.double(xc), as.double(yc), as.integer(length(yc)), as.integer(length(xc)))
			
			res <- matrix(cResult, nrow=length(xc), byrow=TRUE)			
		
			if (!is.null(grid)) {
				attributes(res) <- attributes(grid)
			} else {
				rownames(res) <- xc
				colnames(res) <- yc
			}
			
			UDs[[id1,id2]] <- res
		}
	}
	diag(UDs) <- utilizationDistribution(tr, timestepSize=timestepSize, xc=xc, yc=yc)
	#class(UDs) <- c("utilizationDistribution", "list")
	return(UDs)
}

".UDtimesteps" <- function(tr, timestepSize=60, byburst=FALSE) {
	if (byburst) {
		names <- unique(burst(tr))
	} else {
		names <- unique(id(tr))
	}
	print(names)
	result <- list()
	
	for (name in names) {
		if (byburst) {
			bursts <- tr[sapply(tr, nrow) >= 2][burst=name]
		} else {
			bursts <- tr[sapply(tr, nrow) >= 2][id=name]
		}
		result[[name]] <- do.call("rbind", lapply(bursts, function(burst) {
				burst$t <- as.double(burst$date)
				burst <- burst[!(is.na(burst$x) || is.na(burst$y) || is.na(burst$loc.var)),
				               c("x","y","diff.coeff","loc.var","t")]
				data <- c(t(burst)) # flatten into vector in row-major order
				
				# Align the time of each step to a multiple of timestepSize
				timeLimits <- timestepSize*round(burst$t[c(1,nrow(burst))]/timestepSize)
				nsteps <- as.integer((timeLimits[2] - timeLimits[1]) / timestepSize) + 1
				
				cResult <- .C("UDTimesteps", double(nsteps*4),
						as.integer(nrow(burst)), as.double(data),
						as.integer(nsteps), timeLimits)
				timeSteps <- matrix(cResult[[1]], ncol=4, byrow=T)
				colnames(timeSteps) <- c('x', 'y', 'var', 'weight')
				rownames(timeSteps) <- seq(timeLimits[1], timeLimits[2], length=nrow(timeSteps))
				return(timeSteps)
		}))
		if (byburst) {
			attr(result[[name]], "id") <- attr(bursts[[1]], "id")
		}
	}
	return(result)
}

".defaultGrid" <- function(tr, grid.dim, padding) {
	padding <- rep(padding, length.out=4)

	xr <- range(unlist(sapply(tr, function(b) { b$x })))
	xpad <- padding[c(2,4)] * (xr[2]-xr[1])
	xr <- c(xr[1]-xpad[2], xr[2]+xpad[1])
	
	yr <- range(unlist(sapply(tr, function(b) { b$y })))
	ypad <- padding[c(1,3)] * (yr[2]-yr[1])
	yr <- c(yr[1]-ypad[2], yr[2]+ypad[1])

	cellSize <- min(xr[2] - xr[1], yr[2]-yr[1]) / grid.dim
	
	return(list(
		x=seq(xr[1], xr[2], by=cellSize),
		y=seq(yr[1], yr[2], by=cellSize)
	))
}
